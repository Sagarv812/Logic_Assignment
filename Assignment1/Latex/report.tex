\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{listings} % Added for code blocks
\usepackage{xcolor}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green!60!black},
    breaklines=true,
    frame=single,
    showstringspaces=false
}

\begin{document}

%-------------------- Title Page --------------------%
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\LARGE \textbf{Logic Assignment} \par}
    \vspace{0.5cm}
    {\Large CS 228 \par}
    
    \vspace{4cm}
    
    \textbf{Submitted by:} \par
    Tamanna Kumari, 24B1015 \par
    Sagar V, 24B1021 \par
    
    \vfill
\end{titlepage}

\newpage
\section*{Question 1}

\subsection*{Approach towards encoding Sudoku rules as a CNF}
We categorised 5 constraints which should be encoded.

\subsubsection*{Variable Encoding}

Suppose P(i,j,num) stands true if num occupies row i and column j.
\[1\leq num\leq 9\]  
\[0\leq i,j\leq 8\]

Now we encoded P(i,j,num) as follows:
\[81*i + 9*j + num\]
This gives us numbers from 1 to 729 each corresponding to a unique P(i,j,num).

\subsubsection*{Constraints}
\begin{lstlisting}
    # Encoding all given numbers
    for i in range(9):
        for j in range(9):
            if (grid[i][j] != 0 ):
                box_no = i*9 + j
                cnf.append([box_no*9+grid[i][j]])
\end{lstlisting}

This appends to our cnf that the initial marking of numbers that we have to solve must be true.

\begin{lstlisting}
    # Encoding rows, columns and 3x3 grid condition
    for num in range(9):
        cell = 0
        for i in range(9):
            row_encode = []
            col_encode = []
            box_encode = []

            if(i%3==0):
                cell = 9*i+1
            else:
                cell = cell - 17

            for j in range(9):
                row_encode.append((9*i+j)*9+num+1)
                col_encode.append((i+9*j)*9+num+1)

                box_encode.append((cell-1)*9+num+1)

                if j==8:
                    continue
                if((j+1)%3==0):
                    cell += 7
                else:
                    cell += 1

            cnf.append(row_encode)
            cnf.append(col_encode)
            cnf.append(box_encode)
\end{lstlisting}

Each row must contain atleast one occurence of 1,2,...9
\[
\bigwedge_{\text{num}=1}^{9} \bigwedge_{\text{row}=0}^{8} 
\Bigg( \bigvee_{\text{col}=0}^{8} P(\text{row}, \text{col}, \text{num}) \Bigg)
\]

Each column must contain atleast one occurence of 1,2,...9
\[
\bigwedge_{\text{num}=1}^{9} \bigwedge_{\text{col}=0}^{8} 
\Bigg( \bigvee_{\text{row}=0}^{8} P(\text{row}, \text{col}, \text{num}) \Bigg)
\]

Each 3x3 block must contain atleast one occurence of 1,2,..,9
\[
\bigwedge_{\text{num}=1}^{9} 
\bigwedge_{\text{box\_row}=0}^{2} 
\bigwedge_{\text{box\_col}=0}^{2} 
\Bigg(
\bigvee_{i=0}^{2} \bigvee_{j=0}^{2} 
P(3 \cdot \text{box\_row} + i, 3 \cdot \text{box\_col} + j, \text{num})
\Bigg)
\]

\subsubsection*{Row and Column Encoding Explanation}

We use three nested loops over \texttt{num}, \texttt{i}, and \texttt{j}. Here, \texttt{num} represents the number 1--9, \texttt{i} the row index, and \texttt{j} the column index.

For each row \texttt{i} and number \texttt{num}, we maintain a list \texttt{row\_encode} which represents a single clause, i.e., the disjunction (OR) of all boxes in that row for the given number. Using \texttt{j}, we iterate over all 9 columns/boxes in the row and add the corresponding variable \(P(i, j, num)\) to the clause, ensuring that the number \texttt{num} appears in at least one box of the row.

Similarly, we use \texttt{col\_encode} and iterate using j over all rows/boxes in a particular column and add a clause for every number and every column ensuring that the number num appears in atleast one box of every column.

For encoding atleast one appearance of each number in a 3x3 box,

\subsubsection*{Box Encoding Explanation}

The list \texttt{box\_encode} represents a single clause that ensures a given number \texttt{num} appears at least once in a 3$\times$3 box. The variable \texttt{cell} is used to traverse all 9 cells of the current box in a linearized SAT variable numbering. For each column index \texttt{j}, we append the corresponding SAT variable 
\(
(cell-1) \cdot 9 + num + 1
\) 
to \texttt{box\_encode}. The arithmetic on \texttt{cell} ensures that after each step, we correctly move to the next cell within the 3$\times$3 box, handling the jumps between rows of the box. After iterating over all columns, \texttt{box\_encode} contains all variable indices for the number in that box, and adding it to \texttt{cnf} enforces the "at least one occurrence per box" constraint.



\begin{itemize}
    \item At the start of a new set of three rows (\texttt{i \% 3 == 0}), \texttt{cell} is initialized to the first cell of the top row of the current box: 
    \[
        \texttt{cell} = 9 \cdot i + 1.
    \]
    This sets the starting point for the box in the flattened 9$\times$9 grid numbering.
    
    \item For the second and third rows of the 3$\times$3 box, \texttt{cell} is adjusted backwards by 17: 
    \[
        \texttt{cell} = \texttt{cell} - 17.
    \]
    This moves the pointer from the end of the previous row back to the start of the next row of the box, correctly positioning for the next set of three cells.
    
    \item Within a row of the box, after each column \texttt{j}, \texttt{cell} is incremented to move to the next cell:
    \begin{itemize}
        \item If \texttt{(j+1)\%3 == 0} (i.e., at the end of a mini-row within the box), \texttt{cell} is incremented by 7. This jumps to the first cell of the next mini-row within the 3$\times$3 box.
        \item Otherwise, \texttt{cell} is incremented by 1 to move to the next column in the same mini-row.
    \end{itemize}
\end{itemize}

\subsection*{No two numbers accupy the same box}
We encoded the atleast one rule for each row, column and cell. But it can also be the case that our SAT solver returns true for all P(i,j,num). To avoid such a scenario we encode the condition that for any two numbers they cannot be in the same box.

\begin{lstlisting}
    for i in range(81):
        for j in range(9):
            for k in range(j+1,9):
                cnf.append([-(i*9+j+1), -(i*9+k+1)])        

\end{lstlisting}
\[
\bigwedge_{i=0}^{80} \;\;
\bigwedge_{0 \leq j < k \leq 8}
\left(
  \lnot P(i,j) \;\lor\; \lnot P(i,k)
\right)
\]

\paragraph{}  
The given code generates the clauses that enforce the condition that each cell of the Sudoku grid contains at most one number. The loop variable $i$ ranges from $0$ to $80$, representing the $81$ cells of the board. For each cell, the indices $j$ and $k$ range over the possible numbers $0$ to $8$, with the restriction $j < k$ to avoid repetition. For every such pair, the clause  
\[
\lnot P(i,j+1) \;\lor\; \lnot P(i,k+1)
\]  
is added to the CNF. This guarantees that no two distinct numbers can be simultaneously assigned to the same cell.


Since we have an atleast one occurence in each row, col and cell for all numbers between 1-9 and we have an atmost one number per box condition we have the suffucuent conditions and need not att the condition of atleast one number per box.

\subsection*{Member Contributions}
This question was independently solved and coded by both team members with similar logic and runtime but just slight differences.
Then we discussed and optimized the encoder to give the final submission. 
\newpage
%-------------------- Question 2 --------------------%
\section*{Question 2}

\subsection*{1.1 Padding used and \texttt{self.grid} was modified as follows:}

\begin{lstlisting}
self.grid = grid
arr = np.array(grid)
padded = np.pad(arr, pad_width=1, mode='constant', constant_values='#')
self.grid = padded.tolist()
\end{lstlisting}

In our sokoban encoder class, we have padded the grid with walls (\#) on all sides of the grid. This is done to account for boundary checks while checking for valid moves. This allowed us to club out of bounds and wall checks into a single check for walls (\#).

Consequently, the number of rows and columns were also updated to account for the padded walls.

\begin{lstlisting}
self.rows = len(self.grid)  # here I changed the definition of rows from grid to self.grid so that the padded rows are taken into account.
self.cols = len(self.grid[0]) 
\end{lstlisting}

Also, I changed variables \texttt{N} and \texttt{M} to \texttt{rows} and \texttt{cols} respectively for better readability.

\subsection*{1.2 Variable Encoding used}

We have used the following variable encoding for the given problem:

In \texttt{q2.py} file, we defined 3 new class members:

\begin{lstlisting}
self.c1 = self.num_boxes + 1
self.c2 = self.c1 * self.rows
self.c3 = self.c2 * self.cols
\end{lstlisting}

where \texttt{num\_boxes} = number of boxes, \texttt{rows} = number of rows, \texttt{cols} = number of columns.

To encode a player at position \((x,y)\) at time \(t\):

\begin{lstlisting}
return self.num_boxes + 1  + self.c1*x + self.c2*y + self.c3 * t
\end{lstlisting}

In the rest of the report, we will use \(P(x,y,t)\) to denote the above encoding.

To encode a box with index \(b\) at position \((x,y)\) at time \(t\):

\begin{lstlisting}
return b  + self.c1*x + self.c2*y + self.c3 * t
\end{lstlisting}

This ensures no overlap between player and box encodings. In the rest of the report, we will use \(B(b,x,y,t)\) to denote the above encoding.

Grid parsing is done by checking the grid cell values and updating \texttt{self.goals}, \texttt{self.boxes} and \texttt{self.player} accordingly.
\newpage

\newpage

\subsection*{1.3 Explaining the constraints}

\begin{lstlisting}
# Constraints for initial conditions:
self.cnf.append([self.var_player(self.grid_player_start[0], self.grid_player_start[1],0)])
for index in range(self.num_boxes):
    self.cnf.append([self.var_box(index+1, self.boxes[index][0], self.boxes[index][1], 0)])
\end{lstlisting}

These constraints ensure that the initial positions of the player and boxes are correctly represented in the CNF formula at time step 0.  

We add \texttt{P(player\_start[0], player\_start[1], 0)} to the CNF to indicate the player's starting position.  

For each box, we add \texttt{B(index+1, boxes[index][0], boxes[index][1], 0)} to represent the initial position of each box.



\begin{lstlisting}
# Condition for player movement:
for t in range(self.T):
    for x in range(1, self.rows-1):
        for y in range(1, self.cols-1):
            self.cnf.append([
                -self.var_player(x, y, t),
                self.var_player(x+1, y, t+1),
                self.var_player(x-1, y, t+1),
                self.var_player(x, y+1, t+1),
                self.var_player(x, y-1, t+1),
                self.var_player(x, y, t+1)
            ])
\end{lstlisting}

This constraint ensures that if the player is at position \((x,y)\) at time \(t\), then at time \(t+1\), the player must move to one of the adjacent positions \((x+1,y), (x-1,y), (x,y+1), (x,y-1)\) or remain in the same position \((x,y)\).

Using logical notation, we can express this as:

\[
P(x,y,t) \implies P(x+1,y,t+1) \lor P(x-1,y,t+1) \lor P(x,y+1,t+1) \lor P(x,y-1,t+1) \lor P(x,y,t+1)
\]

Encoded in CNF form, this becomes:

\[
\neg P(x,y,t) \lor P(x+1,y,t+1) \lor P(x-1,y,t+1) \lor P(x,y+1,t+1) \lor P(x,y-1,t+1) \lor P(x,y,t+1)
\]

\noindent This ensures that the player moves to a valid adjacent cell or stays in place at each time step.
\newpage



\begin{lstlisting}
# Condition that if there is a wall, player and boxes can't move through it
for t in range(self.T + 1):
    for x in range(self.rows):
        for y in range(self.cols):
            if self.grid[x][y] == '#':
                self.cnf.append([-self.var_player(x, y, t)])
                for b in range(self.num_boxes):
                    self.cnf.append([-self.var_box(b+1, x, y, t)])
\end{lstlisting}

This constraint ensures that neither the player nor any box can occupy a wall cell at any time step \(t\).  

\begin{itemize}
    \item For each wall cell \((x,y)\) where grid[x][y] is a '\#', we add 
    \[
    \neg P(x,y,t)
    \] 
    to the CNF, indicating that the player cannot be at that position at time \(t\).  

    \item Similarly, for each box \(b\), we add 
    \[
    \neg B(b,x,y,t)
    \] 
    to indicate that box \(b\) cannot be at the wall position \((x,y)\) at time \(t\).  
\end{itemize}

Since the grid has been padded with walls, this also automatically handles out-of-bounds checks.
\newpage


\begin{lstlisting}
# Condition that at a given time, a player and box can be at most in one place
for t in range(self.T + 1):
    atleast_one_place_player = []  # condition that at a given time player must be in at least one place
    for x in range(self.rows):
        for y in range(self.cols):
            atleast_one_place_player.append(self.var_player(x, y, t))
            for xi in range(self.rows):
                for yi in range(self.cols):
                    if (x, y) != (xi, yi):
                        self.cnf.append([-self.var_player(x, y, t), -self.var_player(xi, yi, t)])
                        for b in range(self.num_boxes):
                            self.cnf.append([-self.var_box(b+1, x, y, t), -self.var_box(b+1, xi, yi, t)])
    self.cnf.append(atleast_one_place_player)

# Condition that at a given time, a box must be in at least one place
for t in range(self.T + 1):
    for b in range(self.num_boxes):
        atleast_one_place_box = []
        for x in range(self.rows):
            for y in range(self.cols):
                atleast_one_place_box.append(self.var_box(b+1, x, y, t))
        self.cnf.append(atleast_one_place_box)
\end{lstlisting}

This ensures that at any given time step \(t\), the player and each box occupy exactly one position on the grid.

\subsubsection*{Logical Representation}

\textbf{Player must be in at least one place:}
\[
\forall t, \quad P(x_1, y_1, t) \lor P(x_2, y_2, t) \lor \dots \lor P(x_n, y_n, t)
\]
where \((x_1, y_1), (x_2, y_2), \dots, (x_n, y_n)\) are all valid positions on the grid.

\textbf{Each box must be in at least one place:}
\[
\forall t \; \forall b, \quad B(b, x_1, y_1, t) \lor B(b, x_2, y_2, t) \lor \dots \lor B(b, x_n, y_n, t)
\]
where \((x_1, y_1), (x_2, y_2), \dots, (x_n, y_n)\) are all valid positions on the grid for box \(b\).

\textbf{Player must be in at most one place:}
\[
\forall t, \forall (x_i, y_i) \neq (x_j, y_j), \quad \neg P(x_i, y_i, t) \lor \neg P(x_j, y_j, t)
\]

\textbf{Each box must be in at most one place:}
\[
\forall t, \forall b, \forall (x_i, y_i) \neq (x_j, y_j), \quad \neg B(b, x_i, y_i, t) \lor \neg B(b, x_j, y_j, t)
\]

These constraints guarantee that a player and a box can occupy exactly one place at a time.



\begin{lstlisting}
# Condition that no cell can have more than one box or both a player and a box
for t in range(self.T + 1):
    for x in range(self.rows):
        for y in range(self.cols):
            for b1 in range(self.num_boxes):
                # Player and box cannot occupy the same cell
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b1+1, x, y, t)])
                for b2 in range(b1 + 1, self.num_boxes):
                    # Two boxes cannot occupy the same cell
                    self.cnf.append([-self.var_box(b1 + 1, x, y, t), -self.var_box(b2 + 1, x, y, t)])
\end{lstlisting}

This constraint ensures that no cell on the grid can contain more than one box or both a player and a box at the same time step \(t\).  

- For each cell \((x,y)\) and each box \(b_1\), we add:
\[
\neg P(x,y,t) \lor \neg B(b_1, x, y, t)
\]
to indicate that if the player is at \((x,y)\) at time \(t\), then box \(b_1\) cannot occupy the same position at the same time.  

- For each pair of boxes \(b_1\) and \(b_2\), we add:
\[
\neg B(b_1, x, y, t) \lor \neg B(b_2, x, y, t)
\]
to ensure that two boxes do not occupy the same cell simultaneously.

\subsubsection*{Logical Notation}

\[
\forall t, \forall (x,y), \forall b_1: \quad \neg P(x,y,t) \lor \neg B(b_1,x,y,t)
\]

\[
\forall t, \forall (x,y), \forall b_1 \neq b_2: \quad \neg B(b_1,x,y,t) \lor \neg B(b_2,x,y,t)
\]

\newpage


\begin{lstlisting}
# Condition about moving boxes
for t in range(self.T):
    for b in range(self.num_boxes):
        for x in range(1, self.rows+1):
            for y in range(1, self.cols+1):
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x+1, y, t), self.var_box(b+1, x+1, y, t+1), self.var_box(b+1, x+2, y, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x+1, y, t), self.var_box(b+1, x+1, y, t+1), self.var_player(x+1, y, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x-1, y, t), self.var_box(b+1, x-1, y, t+1), self.var_box(b+1, x-2, y, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x-1, y, t), self.var_box(b+1, x-1, y, t+1), self.var_player(x-1, y, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x, y+1, t), self.var_box(b+1, x, y+1, t+1), self.var_box(b+1, x, y+2, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x, y+1, t), self.var_box(b+1, x, y+1, t+1), self.var_player(x, y+1, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x, y-1, t), self.var_box(b+1, x, y-1, t+1), self.var_box(b+1, x, y-2, t+1)])
                self.cnf.append([-self.var_player(x, y, t), -self.var_box(b+1, x, y-1, t), self.var_box(b+1, x, y-1, t+1), self.var_player(x, y-1, t+1)])
                self.cnf.append([-self.var_box(b+1, x, y, t), self.var_player(x+1, y, t), self.var_player(x-1, y, t), self.var_player(x, y-1, t), self.var_player(x, y+1, t), self.var_box(b+1, x, y, t+1)])
\end{lstlisting}

This constraint ensures that a box can only be moved if the player is adjacent to it and moves into its position, pushing the box to the next cell in the same direction.

\subsubsection*{Logical Notation}

\[
B(b,x+1,y,t) \wedge P(x,y,t) \implies \bigl(B(b,x+2,y,t+1) \wedge P(x+1,y,t+1)\bigr) \vee B(b,x+1,y,t+1)
\]

This means if box \(b\) is at \((x+1,y)\) at time \(t\) and the player is at \((x,y)\) at time \(t\), then at time \(t+1\), either:  
- The box moves to \((x+2,y)\) and the player moves to \((x+1,y)\), or  
- The box stays at \((x+1,y)\).

Encoding this in CNF gives:

\[
\neg P(x,y,t) \lor \neg B(b,x+1,y,t) \lor \bigl(B(b,x+2,y,t+1) \wedge P(x+1,y,t+1)\bigr) \vee B(b,x+1,y,t+1)
\]

Expanding the ANDs:

\[
\neg P(x,y,t) \lor \neg B(b,x+1,y,t) \lor B(b,x+2,y,t+1) \vee B(b,x+1,y,t+1)
\]

\[
\neg P(x,y,t) \lor \neg B(b,x+1,y,t) \lor P(x+1,y,t+1) \vee B(b,x+1,y,t+1)
\]

Similarly, we encode the other directions:

\[
\begin{aligned}
B(b,x-1,y,t) \wedge P(x,y,t) &\implies \bigl(B(b,x-2,y,t+1) \wedge P(x-1,y,t+1)\bigr) \vee B(b,x-1,y,t+1) \\
B(b,x,y+1,t) \wedge P(x,y,t) &\implies \bigl(B(b,x,y+2,t+1) \wedge P(x,y+1,t+1)\bigr) \vee B(b,x,y+1,t+1) \\
B(b,x,y-1,t) \wedge P(x,y,t) &\implies \bigl(B(b,x,y-2,t+1) \wedge P(x,y-1,t+1)\bigr) \vee B(b,x,y-1,t+1)
\end{aligned}
\]

Finally, if the player is not adjacent to the box, the box remains in the same position:

\[
B(b,x,y,t) \wedge \neg \bigl(P(x+1,y,t) \vee P(x-1,y,t) \vee P(x,y+1,t) \vee P(x,y-1,t)\bigr) \implies B(b,x,y,t+1)
\]

In CNF:

\[
\neg B(b,x,y,t) \lor P(x+1,y,t) \lor P(x-1,y,t) \lor P(x,y+1,t) \lor P(x,y-1,t) \lor B(b,x,y,t+1)
\]





\begin{lstlisting}
# Box should be at some goal at t = T
for b in range(self.num_boxes):
    possible = []
    for goal_index in self.goals:
        possible.append(self.var_box(b+1, goal_index[0], goal_index[1], self.T))
    self.cnf.append(possible)
\end{lstlisting}

This constraint ensures that at the final time step \(T\), each box must be on a goal position.  

For each box \(b\), we create a clause that is the **disjunction of all possible goal positions** for that box at time \(T\).  
This means that box \(b\) must be at least one of the goal positions at time \(T\).

\subsubsection*{Logical Notation}

\[
\forall b \; \bigvee_{(x_g, y_g) \in \text{Goals}} B(b, x_g, y_g, T)
\]

where \((x_g, y_g)\) are the coordinates of all goal positions.
\newpage
\subsection*{1.4 Decoding the model to get the sequence of moves}
\begin{lstlisting}
    sequence = []
    positions = []
    for literal in model :
        if literal > 0 : 
            value = literal % encoder.c1
            if value == 0:
                value = encoder.c1
            row = int(((literal - value)%encoder.c2)/encoder.c1)
            col = int(((literal - encoder.c1*row - value)%encoder.c3)/encoder.c2)
            # time = int((literal - encoder.c2*col - encoder.c1 * row - value)/encoder.c3)
            if value == encoder.num_boxes + 1:
                positions.append([row,col])
                if len(positions) > 1:
                    for key in DIRS.keys():
                        if DIRS[key] == ((positions[-1][0] - positions[-2][0]),(positions[-1][1] - positions[-2][-1])):
                            sequence.append(key)
                            break
    #print(sequence)
    return sequence
\end{lstlisting}
This function decodes the model returned by the SAT solver to extract the sequence of moves made by the player.
This basically finds out which literals are true and extracts the player/box positions at each time step. looking at the player's movements it decides the sequence of moves. If our model is UNSAT we return -1 and never call decode.
\subsubsection*{Explanation of the Code}
1. We initialize an empty list \texttt{sequence} to store the moves and an empty list \texttt{positions} to track the player's positions over time.\\
2. We iterate through each literal in the model. If the literal is positive,we decode it first to find out of it's a player or box variable by taking remainder with our first constant \texttt{c1}.\\
3. Important thing to note here is that if remainder = 0 that means our value was \texttt{c1} so we set value = \texttt{c1}.\\
4. Now once we know it's a player or box variable we decode the row and column using the constants \texttt{c1}, \texttt{c2}, and \texttt{c3}. \\
5. If the value corresponds to the player variable (\texttt{num\_boxes + 1}), we append the \((row, col)\) position to the \texttt{positions} list.\\
6. If there are at least two positions in the \texttt{positions} list, we calculate the difference between the last two positions to determine the direction of movement.\\
7. We use a predefined dictionary \texttt{DIRS} to map the position difference to a move direction ('Up', 'Down', 'Left', 'Right') and append to \texttt{sequence}.\\
8. Finally, we return the \texttt{sequence} list containing the series of moves made by the player.\\

\subsection*{1.5 Member Contributions}
Firstly, we both individually derived the CNF clauses for the constraints and then discussed them together to finalize the constraints and their logical representations.
Then we distributed the coding work as follows:
\begin{itemize}
    \item Sagar V implemented the variable encoding, initial conditions, player movement constraints,single occupancy constraints, and wall constraints.
    \item Tamanna Kumari implemented the grid padding, wall constraints,  no overlap constraints, box movement constraints, goal conditions, and the decoding function.
    \item Both of us collaborated on testing and debugging, coming up with additional testcases and experimenting with different values of rows, cols, T etc. 
\end{itemize}

\end{document}
