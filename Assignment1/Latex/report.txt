##Heading

Logic Assignment
CS 228

Submitted by : 
Tamanna Kumari ,  24B1015
Sagar V, 24B1021

##Heading 
Question 1

<content will be inserted here>

##Heading
Question 2

1.1 Padding used and self.grid was modified as follows:

<code>

        self.grid = grid
        arr = np.array(grid)
        padded = np.pad(arr,pad_width=1, mode='constant', constant_values='#')
        self.grid = padded.tolist()

</code>

In our sokoban encoder class, we have padded the grid with walls(#) on all sides of the grid. This is done to account for boundary checks while checking for valid moves.
This allowed us to club out of bounds and wall checks into a single check for walls(#).

Consequently, the number of rows and columns were also updated to account for the padded walls.
<code>
        self.rows = len(self.grid)  #here I changed the definition of rows from grid to self.grid so that the padded rows are taken into account.
        self.cols = len(self.grid[0]) 
</code>

Also I changed variables N and M to rows and cols respectively for better readability.



1.2 Variable Encoding used

We have used the following variable encoding for the given problem:

In q2.py file, we defined 3 new class members:

<code>
        self.c1 = self.num_boxes + 1
        self.c2 = self.c1 * self.rows
        self.c3 = self.c2 * self.cols
</code>

where num_boxes = number of boxes, rows = number of rows, cols = number of columns.

To encode a player at position (x,y) at time t,

<code>
        return self.num_boxes + 1  + self.c1*x + self.c2*y + self.c3 * t
</code>
In the rest of the report, we will use P(x,y,t) to denote the above encoding.

To encode a box with index b at position (x,y) at time t,

<code>
        return b  + self.c1*x + self.c2*y + self.c3 * t
</code>

This ensures no overlap between player and box encodings.
In the rest of the report, we will use B(b,x,y,t) to denote the above encoding.

Grid parsing is done by checking the grid cell values and updateing self.goals, self.boxes and self.player accordingly.

1.3 Explaining the constraints

<code>
        #Constraints for initial conditions:
        self.cnf.append([self.var_player(self.player_start[0], self.player_start[1],0)])
        for index in range(self.num_boxes):
            self.cnf.append([self.var_box(index+1, self.boxes[index][0], self.boxes[index][1], 0)])
</code>
These constraints ensure that the initial positions of the player and boxes are correctly represented in the CNF formula at time step 0.
We add P(player_start[0], player_start[1], 0) to the CNF to indicate the player's starting position.
For each box, we add B(index+1, boxes[index][0], boxes[index][1], 0) to represent the initial position of each box.

<code>
       #condition for player movement:
        for t in range(self.T):
            for x in range(1,self.rows-1):
                for y in range(1,self.cols-1):
                    self.cnf.append([-self.var_player(x,y,t),self.var_player(x+1,y,t+1),self.var_player(x,y-1,t+1),self.var_player(x,y+1,t+1),self.var_player(x-1,y,t+1),self.var_player(x,y,t+1)])
</code>
This constraint ensures that if the player is at position (x,y) at time t, then at time t+1, the player must move to one of the adjacent positions (x+1,y), (x-1,y), (x,y+1), (x,y-1) or stay in the same position (x,y).

P(x,y,t) => P(x+1,y,t+1) OR P(x-1,y,t+1) OR P(x,y+1,t+1) OR P(x,y-1,t+1) OR P(x,y,t+1)
This is encoded in CNF as:
¬P(x,y,t) ∨ P(x+1,y,t+1) ∨ P(x-1,y,t+1) ∨ P(x,y+1,t+1) ∨ P(x,y-1,t+1) ∨ P(x,y,t+1)  

<code>
        #condition that if there is a wall, player and boxes can't move through it
        for t in range(self.T + 1):
            for x in range(self.rows):
                for y in range(self.cols):
                    if self.grid[x][y] == '#':
                        self.cnf.append([-self.var_player(x,y,t)])
                        for b in range(self.num_boxes):
                            self.cnf.append([-self.var_box(b+1,x,y,t)])
</code>
This constraint ensures that neither the player nor any box can occupy a wall cell at any time step t.
For each wall cell (x,y), we add ¬P(x,y,t) to the CNF to indicate that the player cannot be at that position at time t.
Similarly, for each box b, we add ¬B(b,x,y,t) to indicate that box b cannot be at the wall position (x,y) at time t.
This also includes our out of bounds check since we have padded the grid with walls.

<code>
        #condition that at a given time, a player and box can be atmost in one place
        for t in range(self.T + 1):
            atleast_one_place_player = [] #condition that at a given time player must be in atleast one place
            for x in range(self.rows):
                for y in range(self.cols):
                    atleast_one_place_player.append(self.var_player(x,y,t))
                    for xi in range(self.rows):
                        for yi in range(self.cols):
                            if (x,y) != (xi,yi):
                                self.cnf.append([-self.var_player(x,y,t), -self.var_player(xi,yi,t)])
                                for b in range(self.num_boxes):
                                    self.cnf.append([-self.var_box(b+1,x,y,t), -self.var_box(b+1,xi,yi,t)])
            self.cnf.append(atleast_one_place_player)

        #condition that at a given time, a box can atleast be in one place
        for t in range(self.T + 1):
            for b in range(self.num_boxes):
                atleast_one_place_box = []
                for x in range(self.rows):
                    for y in range(self.cols):
                        atleast_one_place_box.append(self.var_box(b+1,x,y,t))
                self.cnf.append(atleast_one_place_box)
        
</code>

Here, we ensure that at any given time step t, the player and each box occupy exactly one position on the grid.

For player being in atleast one place:
 <logical notation>

 for all t P(x1,y1,t) OR P(x2,y2,t) OR ... OR P(xn,yn,t) 
    where (x1,y1), (x2,y2), ..., (xn,yn) are all valid positions on the grid.

 </logical notation>

Similarly for boxes :
    for all t and for all b B(b,x1,y1,t) OR B(b,x2,y2,t) OR ... OR B(b,xn,yn,t) 
        where (x1,y1), (x2,y2), ..., (xn,yn) are all valid positions on the grid for box b.

For player being in atmost one place:
    <logical notation>
    for all t and for all (xi,yi) != (xj,yj) ¬P(xi,yi,t) OR ¬P(xj,yj,t)
        where (xi,yi) and (xj,yj) are any two distinct valid positions on the grid. 
    </logical notation>
Similarly for boxes :
    for all t and for all b and for all (xi,yi) != (xj,yj) ¬B(b,xi,yi,t) OR ¬B(b,xj,yj,t)
        where (xi,yi) and (xj,yj) are any two distinct valid positions on the grid for box b.       

<code>
        #condition that no cell can have more than one box or both a player and a box
        for t in range(self.T + 1):
            for x in range(self.rows):
                for y in range(self.cols):
                    for b1 in range(self.num_boxes):
                        self.cnf.append([-self.var_player(x,y,t), -self.var_box(b1+1,x,y,t)])
                        for b2 in range(b1 + 1, self.num_boxes):
                            self.cnf.append([-self.var_box(b1 + 1, x, y, t), -self.var_box(b2 + 1, x, y, t)])
</code>
This constraint ensures that no cell on the grid can contain more than one box or both a player and a box at the same time step t.
For each cell (x,y) and each box b1, we add ¬P(x,y,t) ∨ ¬B(b1,x,y,t) to the CNF to indicate that if the player is at (x,y) at time t, then box b1 cannot be at the same position at time t.
For each pair of boxes b1 and b2, we add ¬B(b1,x,y,t) ∨ ¬B(b2,x,y,t) to indicate that if box b1 is at (x,y) at time t, then box b2 cannot be at the same position at time t.

<logical notation>
for all t and for all (x,y) and for all b1 ¬P(x,y,t) OR ¬B(b1,x,y,t)
for all t and for all (x,y) and for all b1 != b2 ¬B(b1,x,y,t) OR ¬B(b2,x,y,t)
</logical notation>

<code>
        #condition about moving boxes
        for t in range(self.T):
            for b in range(self.num_boxes):
                for x in range(1,self.rows+1):
                     for y in range(1,self.cols+1):
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x+1,y,t),self.var_box(b+1,x+1,y,t+1),self.var_box(b+1,x+2,y,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x+1,y,t),self.var_box(b+1,x+1,y,t+1),self.var_player(x+1,y,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x-1,y,t),self.var_box(b+1,x-1,y,t+1),self.var_box(b+1,x-2,y,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x-1,y,t),self.var_box(b+1,x-1,y,t+1),self.var_player(x-1,y,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x,y+1,t),self.var_box(b+1,x,y+1,t+1),self.var_box(b+1,x,y+2,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x,y+1,t),self.var_box(b+1,x,y+1,t+1),self.var_player(x,y+1,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x,y-1,t),self.var_box(b+1,x,y-1,t+1),self.var_box(b+1,x,y-2,t+1)])
                         self.cnf.append([-self.var_player(x,y,t),-self.var_box(b+1,x,y-1,t),self.var_box(b+1,x,y-1,t+1),self.var_player(x,y-1,t+1)])
                         self.cnf.append([-self.var_box(b+1,x,y,t) , self.var_player(x+1,y,t) , self.var_player(x-1,y,t), self.var_player(x,y-1,t) , self.var_player(x,y+1,t) , self.var_box(b+1,x,y,t+1)])
</code>
This constraint ensures that a box can only be moved if the player is adjacent to it and moves into its position, pushing the box to the next cell in the same direction.

<logical notation>

B(b,x+1,y,t) AND P(x,y,t) => (B(b,x+2,y,t+1) AND P(x+1,y,t+1)) OR (B(b,x+1,y,t+1))
This means if box b is at (x+1,y) at time t and the player is at (x,y) at time t, then at time t+1, either:
The box moves to (x+2,y) and the player moves to (x+1,y), or
The box stays at (x+1,y).

Encoding this in CNF gives us:
¬P(x,y,t) ∨ ¬B(b,x+1,y,t) ∨ (B(b,x+2,y,t+1) AND P(x+1,y,t+1)) OR (B(b,x+1,y,t+1))
explanding on the ANDs we get:
¬P(x,y,t) ∨ ¬B(b,x+1,y,t) ∨ B(b,x+2,y,t+1)  OR (B(b,x+1,y,t+1))
¬P(x,y,t) ∨ ¬B(b,x+1,y,t) ∨ P(x+1,y,t+1) OR (B(b,x+1,y,t+1))

Similarly we encoded for 
B(b,x-1,y,t) AND P(x,y,t) => (B(b,x-2,y,t+1) AND P(x-1,y,t+1)) OR (B(b,x-1,y,t+1))
B(b,x,y+1,t) AND P(x,y,t) => (B(b,x,y+2,t+1) AND P(x,y+1,t+1)) OR (B(b,x,y+1,t+1))
B(b,x,y-1,t) AND P(x,y,t) => (B(b,x,y-2,t+1) AND P(x,y-1,t+1)) OR (B(b,x,y-1,t+1))

Now one remaining case is when player is not adjacent to the box, in this case the box should remain in the same position in the next time step.
This is encoded as follows:
B(b,x,y,t) AND -(P(x+1,y,t) OR P(x-1,y,t) OR P(x,y+1,t) OR P(x,y-1,t))
=> B(b,x,y,t+1)
This means if box b is at (x,y) at time t and the player is not at any of the adjacent positions, then at time t+1, the box remains at (x,y).
This is encoded in CNF as:
¬B(b,x,y,t) ∨ P(x+1,y,t) ∨ P(x-1,y,t) ∨ P(x,y+1,t) ∨ P(x,y-1,t) ∨ B(b,x,y,t+1)
</logical notation>

<code>
        #box should be at some goal at t=T
        for b in range(self.num_boxes):
            possible = []
            for goal_index in self.goals:
                possible.append(self.var_box(b+1, goal_index[0], goal_index[1],self.T))
            self.cnf.append(possible)
</code>
This constraint ensures that at the final time step T, each box must be on a goal position.
For each box b, we create a clause that is the disjunction of all possible goal positions for that box at time T.
This means that box b must be at least one of the goal positions at time T.
<logical notation>
for all b B(b,goal1_x,goal1_y,T) OR B(b,goal2_x,goal2_y,T) OR ... OR B(b,goalk_x,goalk_y,T)
where (goal1_x,goal1_y), (goal2_x,goal2_y), ..., (goalk_x,goalk_y) are the coordinates of all goal positions
</logical notation>


Row Encoding : 

for all num and for all row P(row,0,num) OR P(row,1,num) OR .. OR P(row,8,num)








